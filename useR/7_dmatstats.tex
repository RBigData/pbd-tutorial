




\section[pbdDMAT eg's]{Examples Using pbdDMAT}
\setcounter{excount}{0}



\subsection{Statistics Examples with pbdDMAT}

\begin{frame}[fragile]
  \begin{exampleblock}{Sample Covariance}\pause
\begin{lstlisting}[title=Serial Code]
Cov.X <- cov(X)
print(Cov.X)
\end{lstlisting}

\begin{lstlisting}[title=Parallel Code]
Cov.X <- cov(X)
print(Cov.X)
\end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile,shrink]
  \begin{exampleblock}{Linear Regression}\pause
\begin{lstlisting}[title=Serial Code]
tX <- t(X)
A <- tX %*% X
B <- tX %*% y

ols <- solve(A) %*% B

# or
ols <- lm.fit(X, y)
\end{lstlisting}
  
\begin{lstlisting}[title=Parallel Code]
tX <- t(X)
A <- tX %*% X
B <- tX %*% y

ols <- solve(A) %*% B

# or
ols <- lm.fit(X, y)
\end{lstlisting}
  \end{exampleblock}
\end{frame}



\begin{frame}[fragile]
\fontsize{8pt}{7.2}\selectfont
  \begin{exampleblock}{Quick Example 3}
\begin{lstlisting}[basicstyle=\tiny,title=\fontsize{8pt}{7.2}\selectfont PCA: pca.r]
library(pbdDMAT, quiet=T)
init.grid()

n <- 1e4
p <- 250

comm.set.seed(diff=T)
x.dmat <- ddmatrix("rnorm", nrow=n, ncol=p, mean=100, sd=25)

pca <- prcomp(x=x.dmat, retx=TRUE, scale=TRUE)
prop_var <- cumsum(pca$sdev)/sum(pca$sdev)
i <- max(min(which(prop_var > 0.9)) - 1, 1)

y.dmat <- pca$x[, 1:i]

comm.cat("\nCols: ", i, "\n", quiet=T)
comm.cat("%Cols:", i/dim(x.dmat)[2], "\n\n", quiet=T)

finalize()
\end{lstlisting}
\vspace{-.4cm}
  \begin{columns}[t,onlytextwidth]
    \begin{column}{0.58\textwidth}
\begin{lstlisting}[basicstyle=\tiny,backgroundcolor=\color{white},keywordstyle=\color{black},title=\fontsize{6pt}{7.2}\selectfont Execute this script via:]
mpirun -np 2 Rscript pca.r
\end{lstlisting}    
    \end{column}
    \hfill
    \begin{column}{0.4\textwidth}
\begin{lstlisting}[basicstyle=\tiny,title=\fontsize{6pt}{7.2}\selectfont Sample Output:]
Cols:  221 
%Cols: 0.884 
\end{lstlisting}
    \end{column}
â€‹  \end{columns}
  \end{exampleblock}
\end{frame}






\subsection{pbdDMAT Example: Generating Data}

\begin{frame}
  \begin{block}{Generating Random Data}\pause
    Using randomly generated matrices is the best way to ``get your feet wet'' with the pbd tools.  You can do this in 2 ways:
    \begin{enumerate}
     \item Generate a global matrix and distribute it.
     \item Generate locally only what is needed.
    \end{enumerate}
  \end{block}
\end{frame}

\begin{frame}[fragile,shrink]
  \begin{exampleblock}{Example \countex:  Random Distributed Matrix Generation}\pause
\begin{lstlisting}[title=Generate a global matrix and distribute it]
library(pbdDMAT, quiet=TRUE)
init.grid()

# Common global on all processors --> distributed
comm.set.seed(diff=FALSE)
x <- matrix(rnorm(100), nrow=10, ncol=10)
x.dmat <- as.ddmatrix(x)

# Global on processor 0 --> distributed
if (comm.rank()==0){
  x <- matrix(rnorm(100), nrow=10, ncol=10)
} else {
  x <- NULL
}
x.dmat <- as.ddmatrix(x)

finalize()
\end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \begin{exampleblock}{Example \countex:  Random Distributed Matrix Generation}\pause
\begin{lstlisting}[title=Generate locally only what is needed]
library(pbdDMAT, quiet=TRUE)
init.grid()

comm.set.seed(diff = TRUE) # good seeds via rlecuyer
x.dmat <- ddmatrix("rnorm", nrow=10, ncol=10)

finalize()
\end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \begin{exampleblock}{Example \countex:  Random Distributed Matrix Generation}\pause
\begin{lstlisting}[title=Generate locally only what is needed]
library(pbdDMAT, quiet=TRUE)
init.grid()

zero.dmat <- ddmatrix(0, nrow=100, ncol=100)
id.dmat <- diag(1, nrow=100, ncol=100)

finalize()
\end{lstlisting}
  \end{exampleblock}
\end{frame}




\subsection{pbdDMAT Example: Converting Between GBD and DMAT}

\begin{frame}[fragile]
  \begin{exampleblock}{Example \countex:  Random Distributed Matrix Generation}\pause
\begin{lstlisting}[title=Convert between GBD and DMAT]
library(pbdDEMO, quiet=TRUE)
init.grid()

comm.set.seed(diff = TRUE)

N.gbd <- 1 + comm.rank()
X.gbd <- matrix(rnorm(N.gbd * 3), ncol = 3)

# convert GBD to DMAT
X.dmat <- gbd2dmat(X.gbd)

# convert DMAT to GBD
new.X.gbd <- dmat2gbd(X.dmat)

# undistribute
X <- as.matrix(X.dmat)

finalize()
\end{lstlisting}
  \end{exampleblock}
\end{frame}



\begin{frame}
  \begin{block}{Distributed Matrices}\pause
  \begin{center}
    pbdDEMO contains many other examples of reading and managing GBD and DMAT data
  \end{center}
  \end{block}
\end{frame}