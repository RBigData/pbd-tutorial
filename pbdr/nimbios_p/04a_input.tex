\section[Input]{Data Input}
\makesubcontentsslides

\subsection{Serial Data Input}

\begin{frame}
\begin{block}{Separate manual: http://r-project.org/}
\begin{itemize}
\item scan()
\item read.table()
\item read.csv()
\item $\cdots$
\item readBin()
\item ncvar\_get()
\item readSocket()
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile,scale,shrink]
  \begin{exampleblock}{CSV Data: Read Serial then Distribute}\pause
\begin{lstlisting}[title=]
library(pbdDMAT)
if(comm.rank() == 0) { # only read on process 0
  x <- read.csv("myfile.csv")
} else {
  x <- NULL
}

dx <- as.ddmatrix(x)
\end{lstlisting}
  \end{exampleblock}
\end{frame}


\subsection{Parallel Data Input}

\begin{frame}
  \begin{block}{New Issues}\pause
    \begin{itemize}
    \item How to read in parallel?
    \item CSV, SQL, NetCDF4, HDF, ADIOS, custom binary
    \item How to partition data across nodes?
    \item How to structure for scalable libraries?
    \item Read directly into form needed or restructure?
    \item $\ldots$
    \item A lot of work needed here!
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile,scale,shrink]
  \begin{exampleblock}{CSV Data}\pause
\begin{lstlisting}[title=Serial Code]
d <- read.csv(``x.csv'')
\end{lstlisting}

\begin{lstlisting}[title=Parallel Code 0\_readcsv.r]
library(pbdDEMO, quiet = TRUE)
init.grid()
dx <- read.csv.ddmatrix("x.csv", header=TRUE,
          sep='','', nrows=10, ncols=10,
          num.rdrs=2, ICTXT=0)
comm.print(dx)
finalize()
\end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile,scale,shrink]
  \begin{exampleblock}{NetCDF4 Data}\pause
    \begin{lstlisting}[title=Parallel Read]
### Must determine who will read what portion(s) and how to assemble them before reading

### parallel read after determining st and co
nc <- nc_open_par(file.name)

nc_var_par_access(nc, "TREFHT")
new.X.gbdc <- ncvar_get(nc, "TREFHT", start = st, count = co)
nc_close(nc)

finalize()
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile,scale,shrink]
  \begin{exampleblock}{Binary Data}\pause
    \begin{lstlisting}[title=3d Block Binary Reader]
library(pbdDMAT, quiet = TRUE)
init.grid()

## Raw data dimensions in file
data.dim <- c(2048, 2048, 2048)

## global subcube definition
g.start <- c(1, 1, 513)
g.dim <- c(64, 64, 1024)

## local dimension and start
my.dim <- g.dim / c(1, 1, comm.size())
my.start <- g.start + c(0, 0, comm.rank()*my.dim[3])

size <- 4 # file is single precision floats
project <- "/lustre/atlas/proj-shared/stf006/d7r/inv_cascade"
filex <- paste(project, "rot_abc_2048_kf50/outs/vx.061.out", sep="/")

vx <- block3d.read(filex, data.dim, my.start, my.dim, size)

save.file <- paste("xyz.RData", comm.rank(), sep="")
save(vx, file=save.file)

## make a ddmatrix from local data
## reshape 3d array into a matrix for PCA (EOF) computation
## first two dimensions become rows and third becomes columns

## local reshape dimensions
my.nrow <- prod(my.dim[1:2])
my.ncol <- my.dim[3]
ldim <- c(my.nrow, my.ncol)

## global reshape dimensions
g.nrow <- prod(g.dim[1:2])
g.ncol <- g.dim[3]
gdim <- c(g.nrow, g.ncol)

## now reshape local
X <- matrix(vx, nrow=my.nrow, ncol=my.ncol, byrow=FALSE)

## glue local pieces into a ddmatrix
X <- new("ddmatrix", Data=X, dim=gdim, ldim=ldim, bldim=ldim, ICTXT=1)

## transform to 2d block cyclic
X <- redistribute(X, bldim=c(8,8), ICTXT=0)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile,scale,shrink]
  \begin{exampleblock}{CSV Data}\pause
    \begin{lstlisting}[title=3d Block Binary Reader]
block3d.read <- function(file, data.dim, my.start, my.dim, size=4) {
    con.x <- file(file, "rb", blocking=TRUE)
    if(isSeekable(con.x)) {

        start <- sum((my.start - 1) * c(1, cumprod(data.dim)[-length(data.dim)]))

        x <- rep(NA, prod(my.dim))
        
        block <- 1:my.dim[1]
        
        for(j in 1:my.dim[3]) {
            sofar <- 0
            for(i in 1:my.dim[2]) {
                seek(con.x, where=start, rw="read", origin="start")
                x[block] <- readBin(con=con.x, what="numeric",
                                    n=my.dim[1], size=size)
                block <- block + my.dim[1]

                start <- start + data.dim[1]*size
                sofar <- sofar + data.dim[1]*size
            }
            start <- start - sofar + data.dim[1]*data.dim[2]*size
        }
    }
  else {
      x <- NULL
      comm.print(paste("Sorry ...", file, "not seakable!"))
  }
    close(con.x)
    x
}
    \end{lstlisting}
  \end{exampleblock}
\end{frame}
